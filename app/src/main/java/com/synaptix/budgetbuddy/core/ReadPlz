======================================================================================
Group 2 - Group Members:
======================================================================================
* Chad Fairlie ST10269509
* Dhiren Ruthenavelu ST10256859
* Kayla Ferreira ST10259527
* Nathan Teixeira ST10249266
======================================================================================
Declaration:
======================================================================================
We declare that this work is our own original work and that no part of it has been
copied from any other source, except where explicitly acknowledged.
======================================================================================
References:
======================================================================================
* ChatGPT was used to help with the design and planning. As well as assisted with
  finding and fixing errors in the code.
* ChatGPT also helped with the forming of comments for the code.
* https://www.youtube.com/watch?v=A_tPafV23DM&list=PLPgs125_L-X9H6J7x4beRU-AxJ4mXe5vX
======================================================================================


üìÅ core/ ‚Äî Core Layer Documentation (Budgeting App)
This layer contains the pure logic of the app ‚Äî no Android dependencies, no database, no UI code. Everything here should be reusable, testable, and clean.

This is where we define what the app does: models, logic, and core functionality.

üì¶ Folders Overview
core/
‚îú‚îÄ‚îÄ model/       # Budget, Expense, Income - clean data structures
‚îú‚îÄ‚îÄ logic/       # Business rules & calculations (e.g. total spent, balance)
‚îî‚îÄ‚îÄ usecase/     # Application-specific actions (e.g. AddExpense, GetMonthlyBudget)


----------------------------------------------------------------------------------------------------
üìÅ model/
Purpose: Represent the main data types your app uses.
These should be pure Kotlin classes ‚Äî no Room annotations or Android stuff.

Example:
    data class Expense(
        val id: String,
        val amount: Double,
        val category: String,
        val timestamp: Long
    )

    data class Budget(
        val id: String,
        val month: String,
        val totalLimit: Double
    )


----------------------------------------------------------------------------------------------------
üìÅ logic/
Purpose: Contains reusable logic and calculations used throughout the app.

Examples:
    - Calculating total expenses this month
    - Finding remaining budget
    - Grouping expenses by category

Example:
    object BudgetCalculator {
        fun calculateRemaining(budget: Double, expenses: List<Expense>): Double {
            val totalSpent = expenses.sumOf { it.amount }
            return budget - totalSpent
        }
    }


----------------------------------------------------------------------------------------------------
üìÅ usecase/
Purpose: Encapsulate specific app actions or flows.
These orchestrate logic and repositories (from data/), and are called from ViewModels.

Examples:
    - AddExpenseUseCase
    - GetMonthlySummaryUseCase
    - UpdateBudgetLimitUseCase

Example:
    class GetRemainingBudgetUseCase(
        private val repo: BudgetRepository // from data layer
    ) {
        suspend fun execute(month: String): Double {
            val budget = repo.getBudgetForMonth(month)
            val expenses = repo.getExpensesForMonth(month)
            return BudgetCalculator.calculateRemaining(budget.totalLimit, expenses)
        }
    }


----------------------------------------------------------------------------------------------------
‚úÖ Key Principles
- No Android stuff allowed (no LiveData, Context, etc.)
- Keep things testable, clean, and reusable
- Use this layer to describe what your app does, not how
